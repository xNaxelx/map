(function(){"use strict";const R=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],F=1,O=8;class S{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,s]=new Uint8Array(t,0,2);if(e!==219)throw new Error("Data does not appear to be in a KDBush format.");const r=s>>4;if(r!==F)throw new Error(`Got v${r} data when expected v${F}.`);const o=R[s&15];if(!o)throw new Error("Unrecognized array type.");const[c]=new Uint16Array(t,2,1),[p]=new Uint32Array(t,4,1);return new S(p,c,o,t)}constructor(t,e=64,s=Float64Array,r){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=s,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const o=R.indexOf(this.ArrayType),c=t*2*this.ArrayType.BYTES_PER_ELEMENT,p=t*this.IndexArrayType.BYTES_PER_ELEMENT,n=(8-p%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${s}.`);r&&r instanceof ArrayBuffer?(this.data=r,this.ids=new this.IndexArrayType(this.data,O,t),this.coords=new this.ArrayType(this.data,O+p+n,t*2),this._pos=t*2,this._finished=!0):(this.data=new ArrayBuffer(O+c+p+n),this.ids=new this.IndexArrayType(this.data,O,t),this.coords=new this.ArrayType(this.data,O+p+n,t*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,(F<<4)+o]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t)}add(t,e){const s=this._pos>>1;return this.ids[s]=s,this.coords[this._pos++]=t,this.coords[this._pos++]=e,s}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return D(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,s,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:c,nodeSize:p}=this,n=[0,o.length-1,0],h=[];for(;n.length;){const l=n.pop()||0,a=n.pop()||0,u=n.pop()||0;if(a-u<=p){for(let f=u;f<=a;f++){const y=c[2*f],m=c[2*f+1];y>=t&&y<=s&&m>=e&&m<=r&&h.push(o[f])}continue}const d=u+a>>1,g=c[2*d],w=c[2*d+1];g>=t&&g<=s&&w>=e&&w<=r&&h.push(o[d]),(l===0?t<=g:e<=w)&&(n.push(u),n.push(d-1),n.push(1-l)),(l===0?s>=g:r>=w)&&(n.push(d+1),n.push(a),n.push(1-l))}return h}within(t,e,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:r,coords:o,nodeSize:c}=this,p=[0,r.length-1,0],n=[],h=s*s;for(;p.length;){const l=p.pop()||0,a=p.pop()||0,u=p.pop()||0;if(a-u<=c){for(let f=u;f<=a;f++)v(o[2*f],o[2*f+1],t,e)<=h&&n.push(r[f]);continue}const d=u+a>>1,g=o[2*d],w=o[2*d+1];v(g,w,t,e)<=h&&n.push(r[d]),(l===0?t-s<=g:e-s<=w)&&(p.push(u),p.push(d-1),p.push(1-l)),(l===0?t+s>=g:e+s>=w)&&(p.push(d+1),p.push(a),p.push(1-l))}return n}}function D(i,t,e,s,r,o){if(r-s<=e)return;const c=s+r>>1;$(i,t,c,s,r,o),D(i,t,e,s,c-1,1-o),D(i,t,e,c+1,r,1-o)}function $(i,t,e,s,r,o){for(;r>s;){if(r-s>600){const h=r-s+1,l=e-s+1,a=Math.log(h),u=.5*Math.exp(2*a/3),d=.5*Math.sqrt(a*u*(h-u)/h)*(l-h/2<0?-1:1),g=Math.max(s,Math.floor(e-l*u/h+d)),w=Math.min(r,Math.floor(e+(h-l)*u/h+d));$(i,t,e,g,w,o)}const c=t[2*e+o];let p=s,n=r;for(P(i,t,s,e),t[2*r+o]>c&&P(i,t,s,r);p<n;){for(P(i,t,p,n),p++,n--;t[2*p+o]<c;)p++;for(;t[2*n+o]>c;)n--}t[2*s+o]===c?P(i,t,s,n):(n++,P(i,t,n,r)),n<=e&&(s=n+1),e<=n&&(r=n-1)}}function P(i,t,e,s){b(i,e,s),b(t,2*e,2*s),b(t,2*e+1,2*s+1)}function b(i,t,e){const s=i[t];i[t]=i[e],i[e]=s}function v(i,t,e,s){const r=i-e,o=t-s;return r*r+o*o}const K={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:i=>i},B=Math.fround||(i=>t=>(i[0]=+t,i[0]))(new Float32Array(1)),A=2,_=3,L=4,M=5,W=6;class E{constructor(t){this.options=Object.assign(Object.create(K),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:s,maxZoom:r}=this.options;e&&console.time("total time");const o=`prepare ${t.length} points`;e&&console.time(o),this.points=t;const c=[];for(let n=0;n<t.length;n++){const h=t[n];if(!h.geometry)continue;const[l,a]=h.geometry.coordinates,u=B(I(l)),d=B(Z(a));c.push(u,d,1/0,n,-1,1),this.options.reduce&&c.push(0)}let p=this.trees[r+1]=this._createTree(c);e&&console.timeEnd(o);for(let n=r;n>=s;n--){const h=+Date.now();p=this.trees[n]=this._createTree(this._cluster(p,n)),e&&console.log("z%d: %d clusters in %dms",n,p.numItems,+Date.now()-h)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const r=Math.max(-90,Math.min(90,t[1]));let o=t[2]===180?180:((t[2]+180)%360+360)%360-180;const c=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,o=180;else if(s>o){const a=this.getClusters([s,r,180,c],e),u=this.getClusters([-180,r,o,c],e);return a.concat(u)}const p=this.trees[this._limitZoom(e)],n=p.range(I(s),Z(c),I(o),Z(r)),h=p.data,l=[];for(const a of n){const u=this.stride*a;l.push(h[u+M]>1?H(h,u,this.clusterProps):this.points[h[u+_]])}return l}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),r="No cluster with the specified id.",o=this.trees[s];if(!o)throw new Error(r);const c=o.data;if(e*this.stride>=c.length)throw new Error(r);const p=this.options.radius/(this.options.extent*Math.pow(2,s-1)),n=c[e*this.stride],h=c[e*this.stride+1],l=o.within(n,h,p),a=[];for(const u of l){const d=u*this.stride;c[d+L]===t&&a.push(c[d+M]>1?H(c,d,this.clusterProps):this.points[c[d+_]])}if(a.length===0)throw new Error(r);return a}getLeaves(t,e,s){e=e||10,s=s||0;const r=[];return this._appendLeaves(r,t,e,s,0),r}getTile(t,e,s){const r=this.trees[this._limitZoom(t)],o=Math.pow(2,t),{extent:c,radius:p}=this.options,n=p/c,h=(s-n)/o,l=(s+1+n)/o,a={features:[]};return this._addTileFeatures(r.range((e-n)/o,h,(e+1+n)/o,l),r.data,e,s,o,a),e===0&&this._addTileFeatures(r.range(1-n/o,h,1,l),r.data,o,s,o,a),e===o-1&&this._addTileFeatures(r.range(0,h,n/o,l),r.data,-1,s,o,a),a.features.length?a:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,s.length!==1)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,r,o){const c=this.getChildren(e);for(const p of c){const n=p.properties;if(n&&n.cluster?o+n.point_count<=r?o+=n.point_count:o=this._appendLeaves(t,n.cluster_id,s,r,o):o<r?o++:t.push(p),t.length===s)break}return o}_createTree(t){const e=new S(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<t.length;s+=this.stride)e.add(t[s],t[s+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,e,s,r,o,c){for(const p of t){const n=p*this.stride,h=e[n+M]>1;let l,a,u;if(h)l=J(e,n,this.clusterProps),a=e[n],u=e[n+1];else{const w=this.points[e[n+_]];l=w.properties;const[f,y]=w.geometry.coordinates;a=I(f),u=Z(y)}const d={type:1,geometry:[[Math.round(this.options.extent*(a*o-s)),Math.round(this.options.extent*(u*o-r))]],tags:l};let g;h||this.options.generateId?g=e[n+_]:g=this.points[e[n+_]].id,g!==void 0&&(d.id=g),c.features.push(d)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:s,extent:r,reduce:o,minPoints:c}=this.options,p=s/(r*Math.pow(2,e)),n=t.data,h=[],l=this.stride;for(let a=0;a<n.length;a+=l){if(n[a+A]<=e)continue;n[a+A]=e;const u=n[a],d=n[a+1],g=t.within(n[a],n[a+1],p),w=n[a+M];let f=w;for(const y of g){const m=y*l;n[m+A]>e&&(f+=n[m+M])}if(f>w&&f>=c){let y=u*w,m=d*w,x,z=-1;const N=((a/l|0)<<5)+(e+1)+this.points.length;for(const k of g){const T=k*l;if(n[T+A]<=e)continue;n[T+A]=e;const G=n[T+M];y+=n[T]*G,m+=n[T+1]*G,n[T+L]=N,o&&(x||(x=this._map(n,a,!0),z=this.clusterProps.length,this.clusterProps.push(x)),o(x,this._map(n,T)))}n[a+L]=N,h.push(y/f,m/f,1/0,N,-1,f),o&&h.push(z)}else{for(let y=0;y<l;y++)h.push(n[a+y]);if(f>1)for(const y of g){const m=y*l;if(!(n[m+A]<=e)){n[m+A]=e;for(let x=0;x<l;x++)h.push(n[m+x])}}}}return h}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+M]>1){const c=this.clusterProps[t[e+W]];return s?Object.assign({},c):c}const r=this.points[t[e+_]].properties,o=this.options.map(r);return s&&o===r?Object.assign({},o):o}}function H(i,t,e){return{type:"Feature",id:i[t+_],properties:J(i,t,e),geometry:{type:"Point",coordinates:[V(i[t]),Y(i[t+1])]}}}function J(i,t,e){const s=i[t+M],r=s>=1e4?`${Math.round(s/1e3)}k`:s>=1e3?`${Math.round(s/100)/10}k`:s,o=i[t+W],c=o===-1?{}:Object.assign({},e[o]);return Object.assign(c,{cluster:!0,cluster_id:i[t+_],point_count:s,point_count_abbreviated:r})}function I(i){return i/360+.5}function Z(i){const t=Math.sin(i*Math.PI/180),e=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return e<0?0:e>1?1:e}function V(i){return(i-.5)*360}function Y(i){const t=(180-i*360)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}const Q=Date.now();let C,U,j=[];self.onmessage=function(i){if(i.data){const t=C[i.data.period];if(!t)return;if(i.data.getClusterExpansionZoom)postMessage({expansionZoom:t.getClusterExpansionZoom(i.data.getClusterExpansionZoom),center:i.data.center});else{const[e,s,r,o]=i.data.bbox,c=r-e,p=o-s,n=[e-c/2,s-p/2,r+c/2,o+p/2],h={borderSigns:[],clusters:new Map};if(C){const l=t.getClusters(n,i.data.zoom);for(const a of l)h.clusters.set(a.id,a)}if(U&&i.data.zoom>13){const l=U.range(n[0],n[1],n[2],n[3]);h.borderSigns=l.map(a=>j[a])}postMessage(h)}}},fetch("map/data/arrests.json").then(i=>i.json()).then(i=>{console.log(`loaded ${i.features.length} points JSON in ${(Date.now()-Q)/1e3}s`);const t={log:!0,radius:48,extent:256,maxZoom:17},e=new E(t).load(i.features.filter(h=>{const l=new Date(h.properties.date),a=new Date;return a.setMonth(new Date().getMonth()-12),l>=a})),s=new E(t).load(i.features.filter(h=>{const l=new Date(h.properties.date),a=new Date;return a.setMonth(new Date().getMonth()-3),l>=a})),r=new E(t).load(i.features.filter(h=>h.properties.date.startsWith("2025"))),o=new E(t).load(i.features.filter(h=>h.properties.date.startsWith("2024"))),c=new E(t).load(i.features.filter(h=>h.properties.date.startsWith("2023"))),p=new E(t).load(i.features.filter(h=>h.properties.date.startsWith("2022"))),n=new E(t).load(i.features);C={last12months:e,last3months:s,year2025:r,year2024:o,year2023:c,year2022:p,all:n},postMessage({clustersReady:!0})}).catch(i=>console.error("Error fetching JSON:",i)),fetch("map/data/signs.txt").then(i=>i.text()).then(i=>{let t=i.trim().split(`
`);const e=new S(t.length);t.map(s=>s.split("	")).map(s=>{const r={country:s[0],title:s[1],lat:parseFloat(s[2]),lng:parseFloat(s[3])};e.add(r.lng,r.lat),j.push(r)}),e.finish(),U=e,postMessage({borderSignsReady:!0})})})();
